<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Ù…ÙØªØ§Ø­ ÙˆÙ„Ø§ Ø®Ø¯Ø¹Ø© â€” Ù†Ø³Ø®Ø© Ø§Ù„Ø¬ÙˆØ§Ù„ (2 Ù„Ø§Ø¹Ø¨ÙŠÙ†)</title>
<style>
  :root { --bg:#0e0f13; --panel:#181a20; --border:#2a2f3a; --muted:#aeb4c2; --accent:#3b82f6; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:#f2f4f8;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,"Noto Sans Arabic",sans-serif}
  header{position:sticky;top:0;background:#12141a;padding:12px 16px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--border);z-index:10}
  h1{margin:0;font-size:16px}
  #app{max-width:960px;margin:0 auto;padding:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .tag{padding:4px 8px;border-radius:999px;background:#1f2430;border:1px solid var(--border);font-size:12px;color:#d7dbe6}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px;margin-top:12px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .hand{display:flex;gap:8px;flex-wrap:wrap}
  .card{background:#20232b;border:1px solid #2c3240;border-radius:12px;padding:10px;min-width:140px}
  .muted{color:var(--muted)}
  button{background:var(--accent);border:none;color:white;border-radius:12px;padding:12px 14px;font-weight:700}
  button.secondary{background:#2b2f3a;color:#e0e5f0}
  button.ghost{background:transparent;border:1px solid var(--border);color:#e0e5f0}
  button:disabled{opacity:.5}
  .stack{border:1px dashed var(--border);border-radius:12px;padding:8px;min-height:48px;display:flex;align-items:center;justify-content:center}
  .log{font:13px ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap;line-height:1.4}
  .title{font-weight:800}
  .flex{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .space{height:6px}
  .section-title{margin:0 0 6px 0;font-size:14px}
  .danger{color:#ff7676}
  .success{color:#59ffa1}
  .center{text-align:center}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap}
  .sep{height:1px;background:var(--border);margin:8px 0}
  .pill{padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:#12141a}
</style>
</head>
<body>
<header>
  <h1>Ù…ÙØªØ§Ø­ ÙˆÙ„Ø§ Ø®Ø¯Ø¹Ø© â€” Ù†Ø³Ø®Ø© Ø§Ù„Ø¬ÙˆØ§Ù„</h1>
  <div class="toolbar">
    <button id="newRoundBtn" class="secondary">Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
    <button id="resetScoreBtn" class="ghost">ØªØµÙÙŠØ± Ø§Ù„Ù†Ù‚Ø§Ø·</button>
  </div>
</header>
<div id="app">

  <div class="row">
    <div class="pill">Ø§Ù„Ø¯ÙˆØ±: <b id="turnLbl"></b></div>
    <div class="pill">Ø£ÙƒØ´Ù†Ø§Øª Ù¡: <b id="a1">0</b></div>
    <div class="pill">Ø£ÙƒØ´Ù†Ø§Øª Ù¢: <b id="a2">0</b></div>
    <div class="pill">Ø§Ù„Ù†Ù‚Ø§Ø·: <b id="scoreLbl">0 - 0</b></div>
  </div>

  <div class="panel grid2">
    <div>
      <div class="flex"><div class="title">Ù„Ø§Ø¹Ø¨ Ù¡</div><div class="tag" id="open1">Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙØªØ­</div></div>
      <div class="space"></div>
      <div class="hand" id="hand1"></div>
    </div>
    <div>
      <div class="flex"><div class="title">Ù„Ø§Ø¹Ø¨ Ù¢</div><div class="tag" id="open2">Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙØªØ­</div></div>
      <div class="space"></div>
      <div class="hand" id="hand2"></div>
    </div>
  </div>

  <div class="panel grid2">
    <div>
      <div class="section-title">Ø§Ù„Ø±Ø²Ù…Ø©</div>
      <div class="toolbar">
        <button id="drawBtn">Ø³Ø­Ø¨ Ø¨Ø·Ø§Ù‚Ø©</button>
        <button id="openBtn" class="secondary">Ù…Ø­Ø§ÙˆÙ„Ø© ÙØªØ­</button>
      </div>
      <div class="space"></div>
      <div class="muted">ÙÙŠ Ø¯ÙˆØ±Ùƒ: **Ø³Ø­Ø¨** Ø£Ùˆ **Ù„Ø¹Ø¨** Ø¨Ø·Ø§Ù‚Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·. Ø­Ø¯ Ø§Ù„ÙŠØ¯ Ù£.</div>
    </div>
    <div>
      <div class="section-title">Ø¨Ø·Ø§Ù‚Ø© Ù…ØªØ±ÙˆÙƒØ© (Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„ØªØ§Ù„ÙŠ)</div>
      <div id="offered" class="stack muted">Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨Ø·Ø§Ù‚Ø© Ù…ØªØ±ÙˆÙƒØ©</div>
    </div>
  </div>

  <div class="panel">
    <div class="flex">
      <div>ğŸ”’ Ù…ÙØªØ§Ø­ ØªØ­Øª Ø§Ù„ÙƒÙ†Ø² (Ù…Ù‚Ù„ÙˆØ¨)</div>
      <div class="tag muted">Ù„Ø§ ÙŠØ¤Ø®Ø° Ø¥Ù„Ø§ Ø¹Ø¨Ø± Ø¨Ø·Ø§Ù‚Ø©/Ù‚Ø¯Ø±Ø©</div>
    </div>
  </div>

  <div class="panel">
    <div class="section-title">Ù†Ø§ÙØ°Ø© Ø±Ø¯Ù‘ (Ù„Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù)</div>
    <div id="reactBox" class="toolbar"></div>
  </div>

  <div class="panel">
    <div class="section-title">Ø§Ù„Ø³Ø¬Ù„</div>
    <div id="log" class="log"></div>
  </div>
</div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const el = id => document.getElementById(id);

  // Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ ÙˆØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯
  const GIVE_IT = "Ø¹Ø·Ù†ÙŠ ÙˆØ§Ù†Øª Ø³Ø§ÙƒØª";     // ØªØ¨Ø§Ø¯Ù„ Ù‚Ø³Ø±ÙŠ
  const BLOCK   = "Ø­Ø±Ù‘Ùƒ Ø¨Ø³";             // Ø±ÙØ¶ (ØªØ±Ø¯ Ø­ØªÙ‰ Ø¶Ø¯ BLOCK)
  const REROLL  = "ÙØ±ØµØ© Ø¬Ø¯ÙŠØ¯Ø©";          // Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙØ§ØªÙŠØ­
  const PEEK    = "Ø¨Ø³ Ø¨Ø´ÙˆÙ";             // Ø£Ø´ÙˆÙ Ø¨Ø·Ø§Ù‚Ø© Ù…Ù† ÙŠØ¯ Ø§Ù„Ø®ØµÙ… (Ø£Ø®ØªØ§Ø± Ø§Ù„ÙÙ‡Ø±Ø³)
  const REFLECT = "Ø¬Ø¨ØªÙ‡Ø§ Ù„Ù†ÙØ³Ùƒ";         // Ø§Ù†Ø¹ÙƒØ§Ø³ (Ù…Ø§ ÙŠØ¹ÙƒØ³ Ø­Ø±Ù‘Ùƒ Ø¨Ø³)

  const ACTIONS_TO_OPEN = 3;
  const HAND_LIMIT = 3;
  const START_HAND = 2;

  const state = {
    turn: 0,
    players: [
      { hand: [], actions: 0, key: null, score: 0 },
      { hand: [], actions: 0, key: null, score: 0 },
    ],
    deck: [],
    offered: null, // {card}
    chestKey: null, // "correct" | "broken"
    waitingReaction: null, // {actor, target, card, continues: fn}
  };

  const log = (t) => { el("log").textContent = t + "\n" + el("log").textContent; };
  const shuffle = (a)=>{ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; };

  function freshDeck(){
    const d=[];
    d.push(...Array(6).fill(GIVE_IT));
    d.push(...Array(6).fill(BLOCK));
    d.push(...Array(4).fill(REROLL));
    d.push(...Array(4).fill(PEEK));
    d.push(...Array(4).fill(REFLECT));
    return shuffle(d);
  }

  function dealKeys(){
    const keys=["correct","broken","broken"];
    shuffle(keys);
    state.players[0].key = keys[0];
    state.players[1].key = keys[1];
    state.chestKey = keys[2];
  }

  function startRound(){
    state.players.forEach(p=>{ p.hand=[]; p.actions=0; });
    state.deck = freshDeck();
    state.offered = null;
    state.waitingReaction = null;
    dealKeys();
    // distribute start hands
    for(let i=0;i<START_HAND;i++){
      state.players[0].hand.push(state.deck.pop());
      state.players[1].hand.push(state.deck.pop());
    }
    render();
    log("Ø¨Ø¯Ø£Øª Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©.");
  }

  function render(){
    el("turnLbl").textContent = state.turn===0? "Ù„Ø§Ø¹Ø¨ Ù¡" : "Ù„Ø§Ø¹Ø¨ Ù¢";
    el("a1").textContent = state.players[0].actions;
    el("a2").textContent = state.players[1].actions;
    el("scoreLbl").textContent = `${state.players[0].score} - ${state.players[1].score}`;
    el("open1").textContent = state.players[0].actions >= ACTIONS_TO_OPEN ? "ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„ÙØªØ­" : "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙØªØ­";
    el("open2").textContent = state.players[1].actions >= ACTIONS_TO_OPEN ? "ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„ÙØªØ­" : "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙØªØ­";

    renderHand(0, el("hand1"));
    renderHand(1, el("hand2"));

    el("offered").textContent = state.offered ? state.offered.card : "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨Ø·Ø§Ù‚Ø© Ù…ØªØ±ÙˆÙƒØ©";

    const cur = state.players[state.turn];
    el("drawBtn").disabled = cur.hand.length >= HAND_LIMIT || !!state.waitingReaction;
    el("openBtn").disabled = !(cur.actions >= ACTIONS_TO_OPEN) || !!state.waitingReaction;

    // reaction UI
    renderReactBox();
  }

  function renderHand(idx, container){
    container.innerHTML = "";
    const isTurn = idx===state.turn;
    const disabled = !!state.waitingReaction || !isTurn;
    state.players[idx].hand.forEach((c,i)=>{
      const div = document.createElement("div");
      div.className = "card";
      const small = (c===BLOCK || c===REFLECT) ? "<div class='muted'>Ø¨Ø·Ø§Ù‚Ø© Ø±Ø¯Ù‘</div>" : "<div class='muted'>Ø§Ø¶ØºØ· Ù„Ù„Ø¹Ø¨</div>";
      div.innerHTML = `<b>${c}</b>${small}`;
      if (!disabled) {
        div.style.cursor = "pointer";
        div.onclick = ()=> playCard(idx,i);
      } else {
        div.style.opacity = ".7";
      }
      container.appendChild(div);
    });
    if (state.players[idx].hand.length===0){
      const d = document.createElement("div");
      d.className="muted";
      d.textContent="Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨Ø·Ø§Ù‚Ø§Øª";
      container.appendChild(d);
    }
  }

  function renderReactBox(){
    const box = el("reactBox");
    box.innerHTML = "";
    if (!state.waitingReaction) return;
    const {actor,target,card} = state.waitingReaction;
    const tgt = state.players[target];
    const bIdx = tgt.hand.indexOf(BLOCK);
    const rIdx = tgt.hand.indexOf(REFLECT);
    const title = document.createElement("div");
    title.className="muted";
    title.textContent = `Ø£Ù†Øª Ù…ÙØ³ØªÙ‡Ø¯Ù Ø¨"${card}". ØªØ¨ÙŠ ØªØ±Ø¯ØŸ`;
    box.appendChild(title);

    if (bIdx!==-1){
      const b = document.createElement("button");
      b.textContent = "Ø£Ù„Ø¹Ø¨ Ø­Ø±Ù‘Ùƒ Ø¨Ø³";
      b.onclick = ()=>doBlock(actor,target,card,bIdx);
      box.appendChild(b);
    }
    if (rIdx!==-1 && card !== BLOCK){
      const r = document.createElement("button");
      r.className="secondary";
      r.textContent = "Ø£Ù„Ø¹Ø¨ Ø¬Ø¨ØªÙ‡Ø§ Ù„Ù†ÙØ³Ùƒ";
      r.onclick = ()=>doReflect(actor,target,card,rIdx);
      box.appendChild(r);
    }
    const n = document.createElement("button");
    n.className="ghost";
    n.textContent = "Ø¨Ø¯ÙˆÙ† Ø±Ø¯";
    n.onclick = ()=>proceedEffect(actor,target,card);
    box.appendChild(n);
  }

  function nextTurn(){
    state.turn = 1 - state.turn;
    render();
  }

  // --- Drawing ---
  async function draw(){
    if (state.waitingReaction) return;
    const me = state.turn;
    const player = state.players[me];
    if (player.hand.length >= HAND_LIMIT) return;

    // take offered?
    if (state.offered){
      // take it
      player.hand.push(state.offered.card);
      log(`Ù„Ø§Ø¹Ø¨ ${me+1} Ø£Ø®Ø° Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ù…ØªØ±ÙˆÙƒØ©.`);
      state.offered = null;
      player.actions++;
      nextTurn();
      return;
    }

    // reveal first privately: here we simulate privacy by just letting the user decide via two buttons:
    // We'll present first card text in log for prototype simplicity.
    const first = state.deck.pop();
    // UI choice inline:
    // Create a small inline choice row
    const box = el("reactBox");
    box.innerHTML = "";
    const title = document.createElement("div");
    title.className="muted";
    title.textContent = `Ø´ÙØª Ø§Ù„Ø£ÙˆÙ„Ù‰: "${first}". ØªØ®ØªØ§Ø± Ø£ÙŠØ´ØŸ`;
    box.appendChild(title);

    const takeFirst = document.createElement("button");
    takeFirst.textContent = "Ø¢Ø®Ø° Ø§Ù„Ø£ÙˆÙ„Ù‰";
    takeFirst.onclick = ()=>{
      player.hand.push(first);
      log(`Ù„Ø§Ø¹Ø¨ ${me+1} Ø³Ø­Ø¨ Ø§Ù„Ø£ÙˆÙ„Ù‰.`);
      player.actions++;
      box.innerHTML="";
      nextTurn();
    };
    box.appendChild(takeFirst);

    const takeSecond = document.createElement("button");
    takeSecond.className="secondary";
    takeSecond.textContent = "Ø£ØªØ±ÙƒÙ‡Ø§ ÙˆØ¢Ø®Ø° Ø§Ù„Ø«Ø§Ù†ÙŠØ©";
    takeSecond.onclick = ()=>{
      state.offered = {card:first};
      const second = state.deck.pop();
      player.hand.push(second);
      log(`Ù„Ø§Ø¹Ø¨ ${me+1} ØªØ±Ùƒ Ø§Ù„Ø£ÙˆÙ„Ù‰ ÙˆØ£Ø®Ø° Ø§Ù„Ø«Ø§Ù†ÙŠØ©.`);
      player.actions++;
      box.innerHTML="";
      nextTurn();
    };
    box.appendChild(takeSecond);

    render();
  }

  // --- Card Play ---
  function playCard(playerIdx, handIdx){
    if (playerIdx !== state.turn) return;
    if (state.waitingReaction) return;
    const card = state.players[playerIdx].hand[handIdx];

    // BLOCK & REFLECT are reaction-only
    if (card===BLOCK || card===REFLECT){
      log("Ù‡Ø°Ù‡ Ø¨Ø·Ø§Ù‚Ø© Ø±Ø¯Ù‘. Ø§Ø³ØªØ®Ø¯Ù…Ù‡Ø§ Ø¹Ù†Ø¯Ù…Ø§ ØªÙØ³ØªÙ‡Ø¯Ù.");
      return;
    }

    const targetIdx = 1 - playerIdx;
    // open reaction window for targeted effects
    if (card===GIVE_IT || card===PEEK || card===REROLL){
      // put into waitingReaction
      state.waitingReaction = {
        actor: playerIdx,
        target: targetIdx,
        card: card,
        handIdx: handIdx,
      };
      render();
      return;
    }

    render();
  }

  function doBlock(actor,target,card,blockIdx){
    // target plays BLOCK, actor may counter-block
    const a = state.players[actor];
    const t = state.players[target];
    const actorBlock = a.hand.indexOf(BLOCK);
    if (actorBlock !== -1){
      // counter play: actor uses BLOCK to break the block
      a.hand.splice(actorBlock,1);
      t.hand.splice(blockIdx,1);
      log(`ØªØ±Ø§Ø´Ù‚ "Ø­Ø±Ù‘Ùƒ Ø¨Ø³": ØªÙ… ÙƒØ³Ø± Ø§Ù„Ø±ÙØ¶.`);
      // proceed effect
      state.waitingReaction = null;
      applyEffect(actor,target);
    } else {
      // cancel
      t.hand.splice(blockIdx,1);
      log(`ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø£Ø«Ø± Ø¨ÙˆØ§Ø³Ø·Ø© "Ø­Ø±Ù‘Ùƒ Ø¨Ø³".`);
      consumeActorCard(actor);
      endAction(actor);
    }
    render();
  }

  function doReflect(actor,target,card,reflectIdx){
    // actor may block the reflect
    const a = state.players[actor];
    const t = state.players[target];
    const actorBlock = a.hand.indexOf(BLOCK);
    if (actorBlock !== -1){
      // actor blocks the reflect
      a.hand.splice(actorBlock,1);
      t.hand.splice(reflectIdx,1);
      log(`ØªÙ… Ù…Ù†Ø¹ Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³ Ø¨ÙˆØ§Ø³Ø·Ø© "Ø­Ø±Ù‘Ùƒ Ø¨Ø³".`);
      state.waitingReaction = null;
      applyEffect(actor,target);
    } else {
      // reflect happens
      t.hand.splice(reflectIdx,1);
      log(`Ø§Ù†Ø¹ÙƒØ§Ø³! "${state.waitingReaction.card}" Ø±Ø¬Ø¹Øª Ø¹Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨ ${actor+1}.`);
      state.waitingReaction = null;
      // invert effect target
      applyEffect(target, actor, /*reflected*/true);
    }
    render();
  }

  function proceedEffect(actor,target,card){
    state.waitingReaction = null;
    applyEffect(actor,target);
    render();
  }

  function consumeActorCard(actor){
    const {handIdx} = state._lastPlayed || {};
    // Fallback: remove by card lookup
    const waiting = state.waitingReaction;
    if (waiting){
      // remove using waiting.handIdx
      const idx = waiting.handIdx;
      if (idx!=null){
        state.players[actor].hand.splice(idx,1);
      }
    } else if (handIdx!=null){
      state.players[actor].hand.splice(handIdx,1);
    }
  }

  function endAction(actor){
    state.players[actor].actions++;
    nextTurn();
  }

  function applyEffect(actor,target,reflected=false){
    const waiting = state.waitingReaction;
    if (!waiting) return;
    const {card, handIdx} = waiting;
    // consume actor's card first
    state.players[actor].hand.splice(handIdx,1);

    if (card===GIVE_IT){
      // forced swap
      const tmp = state.players[actor].key;
      state.players[actor].key = state.players[target].key;
      state.players[target].key = tmp;
      log(`ØªÙ… ØªØ¨Ø§Ø¯Ù„ Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø¨ÙŠÙ† Ù„Ø§Ø¹Ø¨ ${actor+1} ÙˆÙ„Ø§Ø¹Ø¨ ${target+1}.`);
    }
    else if (card===PEEK){
      // show list of target hand, let target choose index? (Design says actor chooses which to peek)
      if (state.players[target].hand.length===0){
        log(`Ø®ØµÙ…Ùƒ Ù…Ø§ Ø¹Ù†Ø¯Ù‡ Ø¨Ø·Ø§Ù‚Ø§Øª Ù„ØªØ±Ø§Ù‡Ø§.`);
      } else {
        // For prototype: reveal first card name in log to actor info (both can see in pass-and-play)
        const idx = 0; // simplify: peek first
        const seen = state.players[target].hand[idx];
        log(`Ù„Ø§Ø¹Ø¨ ${actor+1} Ø´Ø§Ù Ø¨Ø·Ø§Ù‚Ø© Ù…Ù† ÙŠØ¯ Ø®ØµÙ…Ù‡: "${seen}".`);
      }
    }
    else if (card===REROLL){
      const pool=["correct","broken","broken"];
      shuffle(pool);
      state.players[0].key = pool[0];
      state.players[1].key = pool[1];
      state.chestKey = pool[2];
      log(`ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙØ§ØªÙŠØ­.`);
    }

    state.waitingReaction = null;
    endAction(actor);
  }

  // --- Opening chest ---
  function tryOpen(){
    if (state.waitingReaction) return;
    const me = state.turn;
    const p = state.players[me];
    if (p.actions < ACTIONS_TO_OPEN) return;

    if (p.key === "correct"){
      p.score += 2;
      log(`ğŸ‰ Ù„Ø§Ø¹Ø¨ ${me+1} ÙØªØ­ Ø§Ù„ÙƒÙ†Ø² (+2).`);
      startRound();
    } else {
      const opp = state.players[1-me];
      opp.score += 1;
      log(`âŒ Ù„Ø§Ø¹Ø¨ ${me+1} ÙØ´Ù„ ÙÙŠ Ø§Ù„ÙØªØ­ (+1 Ù„Ù„Ø®ØµÙ…).`);
      startRound();
    }
  }

  // --- Events ---
  el("drawBtn").onclick = draw;
  el("openBtn").onclick = tryOpen;
  el("newRoundBtn").onclick = startRound;
  el("resetScoreBtn").onclick = ()=>{
    state.players[0].score=0;
    state.players[1].score=0;
    startRound();
  };

  // --- Init ---
  startRound();
})();
</script>
</body>
</html>
